/**
 *  Generated by ipcc.py. Any changes will be overwritten
 *
 * Namespace: test
 *
 * Client messages:
 *
 *   async greet {
 *     uint32_t number;
 *     uint64_t time;
 *   }
 *
 *
 * Server messages:
 *
 *   async greet {
 *     uint32_t number;
 *     uint64_t time;
 *   }
 *
 */
#pragma once
#include <ck/ipc.h>
#include <stdint.h>
#include <unistd.h>


namespace test {

  // An enumerated identifier for each kind of message
  enum class Message : uint32_t {
    GREET
  };


  class client_connection_stub : public ck::ipc::impl::socket_connection {
    public:
      client_connection_stub(ck::ref<ck::ipcsocket> s) : ck::ipc::impl::socket_connection(s, "test", false) {}
      virtual ~client_connection_stub(void) {}

      // methods to send messages
      inline void greet(uint32_t number, uint64_t time) {
        ck::ipc::encoder __e = begin_send();
        __e << (uint32_t)test::Message::GREET;
        ck::ipc::encode(__e, number);
        ck::ipc::encode(__e, time);
        this->finish_send();
      }


      // handle these in your subclass


    protected:
      // ^ck::ipc::impl::client_connection
      virtual inline void dispatch_received_message(void *data, size_t len) {
        ck::ipc::decoder __decoder(data, len);
        test::Message msg_type = (test::Message)ck::ipc::decode<uint32_t>(__decoder);
        switch (msg_type) {
          default:
            panic("Unhandled message type %d", msg_type);
            break;
        }
      }

  };


  class server_connection_stub : public ck::ipc::impl::socket_connection {
    public:
      server_connection_stub(ck::ref<ck::ipcsocket> s) : ck::ipc::impl::socket_connection(s, "test", true) {}
      virtual ~server_connection_stub(void) {}

      // methods to send messages

      // handle these in your subclass
      virtual void on_greet(uint32_t number, uint64_t time) = 0;


    protected:
      // ^ck::ipc::impl::server_connection
      virtual inline void dispatch_received_message(void *data, size_t len) {
        ck::ipc::decoder __decoder(data, len);
        test::Message msg_type = (test::Message)ck::ipc::decode<uint32_t>(__decoder);
        switch (msg_type) {
          case test::Message::GREET: {
            uint32_t number;
            ck::ipc::decode(__decoder, number);
            uint64_t time;
            ck::ipc::decode(__decoder, time);
            on_greet(number, time);
            break;
          }
          default:
            panic("Unhandled message type %d", msg_type);
            break;
        }
      }

  };


}
