#!/bin/env python3

from lark import Lark, Transformer
from typing import List
from dataclasses import dataclass
import itertools
import sys

grammar = '''
start: (namespace | source )+

namespace: "namespace" NAME

source: SRC_TYPE "{" message+ "}"

message: MSG_TYPE NAME "{" field+ "}"

field: NAME NAME ";"
 
NAME: /[\w:]/+

SRC_TYPE: "client"|"server"
MSG_TYPE: "sync"|"async"

COMMENT: /#.*/

%import common.LETTER
%import common.INT -> NUMBER
%import common.WS
%ignore WS
%ignore COMMENT
'''

parser = Lark(grammar)


@dataclass
class Field:
   type: str
   name: str

   def __repr__(self):
      return f'{self.type} {self.name};'

@dataclass
class Message:
   type: str
   name: str
   fields: List[Field]

   def __repr__(self):
      return f'{self.type} {self.name} {{ {" ".join(map(str, self.fields))} }}'


@dataclass
class Source:
   type: str
   msgs: List[Message]

@dataclass
class Namespace:
   name: str


class MyTransformer(Transformer):

   def SRC_TYPE(self, m):
      return str(m)

   def MSG_TYPE(self, m):
      return str(m)

   def NAME(self, name):
      return str(name)

   def field(self, f):
      (t, n) = f
      return Field(t, n)

   def message(self, m):
      return Message(m[0], m[1], m[2:])

   def source(self, s):
      t = s[0]
      m = s[1:]
      return Source(t, m)

   def start(self, s):
      return s


   def namespace(self, n):
      return Namespace(n[0])



class IPCCompiler:
   def __init__(self, tree):
      self.tree = tree
      self.namespace = None

      self.client_messages = []
      self.server_messages = []

      self.all_msgs = []
      self.send_map = {}
      self.recv_map = {}

      # go over the top level and decode it
      for tl in tree:
         if isinstance(tl, Namespace):
            self.namespace = tl.name

         if isinstance(tl, Source):
            self.all_msgs.extend(tl.msgs)
            if tl.type == 'client':
               self.send_map['client'] = tl.msgs
               self.recv_map['server'] = tl.msgs
            elif tl.type == 'server':
               self.send_map['server'] = tl.msgs
               self.recv_map['client'] = tl.msgs


      if self.namespace is None:
         raise Exception("No namespace defined")



   def compile_header(self, file):

      def out(*lines):
         file.write('\n'.join(lines) + '\n')

      out('/**')
      out(' *  Generated by ipcc.py. Any changes will be overwritten')
      out(' *')
      out(' * Namespace: {}'.format(self.namespace))
      out(' *')
      out(' * Client messages:')
      out(' *')
      for m in self.send_map['client']:
         out(f' *   {m.type} {m.name} {{')
         for f in m.fields:
            out(f' *     {f.type} {f.name};')
         out(f' *   }}')
         out(f' *')


      out(' *')
      out(' * Server messages:')
      out(' *')
      for m in self.send_map['client']:
         out(f' *   {m.type} {m.name} {{')
         for f in m.fields:
            out(f' *     {f.type} {f.name};')
         out(f' *   }}')
         out(f' *')
      out(' */')


      out('#pragma once')
      out('#include <ck/ipc.h>')
      out('#include <stdint.h>')
      out('#include <unistd.h>')


      out('\n')
      out(f'namespace {self.namespace} {{')
      out('')


      out(f'  // An enumerated identifier for each kind of message')
      out(f'  enum class Message : uint32_t {{')
      enum_vals = ",\n    ".join(map(lambda m: f'{m.name.upper()}', self.all_msgs))
      out(f'    {enum_vals}')
      out(f'  }};\n\n')


      for tl in self.tree:
         if isinstance(tl, Source):
            typename = tl.type
            out(f'  class {typename}_stub : public ck::ipc::impl::{typename} {{')
            out(f'    public:')
            out(f'      virtual ~{typename}_stub(void) {{}}')
            out('')

            out(f'      // methods to send messages')
            for m in self.send_map[typename]:
               args = [f'{f.type} {f.name}' for f in m.fields]
               args = [f'{f.type} {f.name}' for f in m.fields]
               out(f'      inline void {m.name}({", ".join(args)}) {{')
               out(f'        ck::ipc::encoder e;')
               out(f'        e << (uint32_t){self.namespace}::Message::{m.name.upper()});')
               out(f'        e << {" << ".join(f.name for f in m.fields)};')

               out(f'        this->send_raw_{m.type}(e.buffer(), e.size());')
               out(f'      }}')
               out()

            out('')
            out(f'      // handle these in your subclass')
            for m in self.recv_map[typename]:
               args = [f'{f.type} {f.name}' for f in m.fields]
               out(f'      virtual void on_{m.name}({", ".join(args)}) = 0;')
            out('')
            out('')

            out(f'    protected:')
            out(f'      // ^ck::ipc::base_{typename}')
            out(f'      virtual inline void dispatch_received_message(void *data, size_t len) {{')
            out(f'        ck::ipc::decoder __decoder(data, len);')
            out(f'        auto msg_type = ck::ipc::decode<uint32_t>(__decoder);')
            out(f'        switch (msg_type) {{')
            for m in self.recv_map[typename]:
               out(f'          case {m.name.upper()}: {{')
               for field in m.fields:
                  out(f'            auto {field.name} = ipc::decode<{field.type}>(__decoder);')
               args = [f'{f.name}' for f in m.fields]

               out(f'            on_{m.name}({", ".join(args)});')
               out(f'            break;')
               out(f'          }}')

            out(f'        }}')
            out(f'      }}\n')
            out(f'  }};\n\n')

      out(f'}}')


   def compile(self, basename):
      with open(basename + '.h', 'w') as f:
         self.compile_header(f)


      
      





def main():
   with open(sys.argv[1], 'r') as f:
      input = f.read()

   basename = sys.argv[1].replace('.ipc', '')
   
   tree = MyTransformer().transform(parser.parse(input))

   compiler = IPCCompiler(tree)

   compiler.compile(basename)





if __name__ == '__main__':
   main()
