#!/bin/env python3

from lark import Lark, Transformer
from typing import List
from dataclasses import dataclass
import itertools
import sys

grammar = '''
start: (namespace | source | header )+

namespace: "namespace" NAME

source: SRC_TYPE "{" message* "}"

message: MSG_TYPE NAME "(" [ field ("," field)* ] ")"

field: NAME NAME ("=" (STRING | NUMBER))?


header: "header" PATH

PATH: /[\w\.\/]/+
 
NAME: /[\w:]/+

SRC_TYPE: "client"|"server"
MSG_TYPE: "sync"|"async"

COMMENT: /\/\/.*/

%import common.LETTER
%import common.ESCAPED_STRING   -> STRING
%import common.SIGNED_NUMBER    -> NUMBER
%import common.WS
%ignore WS
%ignore COMMENT
'''

parser = Lark(grammar)


@dataclass
class Field:
   type: str
   name: str
   default: str

   def __repr__(self):
      return f'{self.type} {self.name};'

   def default_str(self):
      if self.default is None:
         return ''
      return f' = {self.default}'


@dataclass
class Message:
   type: str
   name: str
   fields: List[Field]

   def __repr__(self):
      return f'{self.type} {self.name} {{ {" ".join(map(str, self.fields))} }}'


@dataclass
class Source:
   type: str
   msgs: List[Message]

@dataclass
class Namespace:
   name: str

@dataclass
class Header:
   hdr: str


class MyTransformer(Transformer):

   def SRC_TYPE(self, m):
      return str(m)

   def MSG_TYPE(self, m):
      return str(m)

   def NAME(self, name):
      return str(name)

   def field(self, f):
      if len(f) == 3:
         (t, n, d) = f
         return Field(t, n, d)

      return Field(f[0], f[1], None)

   def message(self, m):
      return Message(m[0], m[1], m[2:])

   def source(self, s):
      t = s[0]
      m = s[1:]
      return Source(t, m)

   def start(self, s):
      return s


   def namespace(self, n):
      return Namespace(n[0])

   def header(self, h):
      return Header(str(h[0]))



class IPCCompiler:
   def __init__(self, tree):
      self.tree = tree
      self.namespace = None
      self.header = None


      self.client_messages = []
      self.server_messages = []

      self.all_msgs = []
      self.send_map = {}
      self.recv_map = {}


      # go over the top level and decode it
      for tl in tree:
         if isinstance(tl, Namespace):
            self.namespace = tl.name

         if isinstance(tl, Header):
            self.header = tl.hdr

         if isinstance(tl, Source):
            self.all_msgs.extend(tl.msgs)
            if tl.type == 'client':
               self.send_map['client'] = tl.msgs
               self.recv_map['server'] = tl.msgs
            elif tl.type == 'server':
               self.send_map['server'] = tl.msgs
               self.recv_map['client'] = tl.msgs


      if self.namespace is None:
         raise Exception("No namespace defined")

      
      if self.header is None:
         raise Exception("No header defined")



   def compile_header(self, file):

      def out(*lines):
         file.write('\n'.join(lines) + '\n')

      out('/**')
      out(' *  Generated by ipcc.py. Any changes will be overwritten')
      out(' *')
      out(' * Namespace: {}'.format(self.namespace))
      out(' *')
      out(' * Client messages:')
      out(' *')
      for m in self.send_map['client']:
         out(f' *   {m.type} {m.name} {{')
         for f in m.fields:
            out(f' *     {f.type} {f.name};')
         out(f' *   }}')
         out(f' *')


      out(' *')
      out(' * Server messages:')
      out(' *')
      for m in self.send_map['client']:
         out(f' *   {m.type} {m.name} {{')
         for f in m.fields:
            out(f' *     {f.type} {f.name};')
         out(f' *   }}')
         out(f' *')
      out(' */')


      out('#pragma once')
      out('#include <ck/ipc.h>')
      out('#include <stdint.h>')
      out('#include <unistd.h>')


      out('\n')
      out(f'namespace {self.namespace} {{')
      out('')


      out(f'  // An enumerated identifier for each kind of message')
      out(f'  enum class Message : uint32_t {{')
      enum_vals = ",\n    ".join(map(lambda m: f'{m.name.upper()}', self.all_msgs))
      out(f'    {enum_vals}')
      out(f'  }};\n\n')


      for tl in self.tree:
         if isinstance(tl, Source):
            typename = tl.type
            out(f'  class {typename}_connection_stub : public ck::ipc::impl::socket_connection {{')
            out(f'    public:')
            out(f'      {typename}_connection_stub(ck::ref<ck::ipcsocket> s) : ck::ipc::impl::socket_connection(s, "{self.namespace}", {"true" if typename == "server" else "false"}) {{}}')
            out(f'      virtual ~{typename}_connection_stub(void) {{}}')
            out('')

            out(f'      // methods to send messages')
            for m in self.send_map[typename]:
               args = [f'{f.type} {f.name}{f.default_str()}' for f in m.fields]
               out(f'      inline void {m.name}({", ".join(args)}) {{')
               out(f'        ck::ipc::encoder __e = begin_send();')
               out(f'        __e << (uint32_t){self.namespace}::Message::{m.name.upper()};')
               for field in m.fields:
                  out(f'        ck::ipc::encode(__e, {field.name});')

               out(f'        this->finish_send();')
               out(f'      }}')
               out()

            out('')
            out(f'      // handle these in your subclass')
            for m in self.recv_map[typename]:
               args = [f'{f.type} {f.name}{f.default_str()}' for f in m.fields]
               out(f'      virtual void on_{m.name}({", ".join(args)}) = 0;')
            out('')
            out('')

            out(f'    protected:')
            out(f'      // ^ck::ipc::impl::{typename}_connection')
            out(f'      virtual inline void dispatch_received_message(void *data, size_t len) {{')
            out(f'        ck::ipc::decoder __decoder(data, len);')
            out(f'        {self.namespace}::Message msg_type = ({self.namespace}::Message)ck::ipc::decode<uint32_t>(__decoder);')

            out(f'        switch (msg_type) {{')
            for m in self.recv_map[typename]:
               out(f'          case {self.namespace}::Message::{m.name.upper()}: {{')
               for field in m.fields:
                  out(f'            {field.type} {field.name};')
                  out(f'            ck::ipc::decode(__decoder, {field.name});')

               args = [f'{f.name}' for f in m.fields]

               out(f'            on_{m.name}({", ".join(args)});')
               out(f'            break;')
               out(f'          }}')

            out(f'          default:')
            out(f'            panic("Unhandled message type %d", msg_type);')
            out(f'            break;')

            out(f'        }}')
            out(f'      }}\n')
            out(f'  }};\n\n')

      out(f'}}')


   def compile(self, basename):
      with open('./' + self.header, 'w') as f:
         self.compile_header(f)


      
      





def main():
   with open(sys.argv[1], 'r') as f:
      input = f.read()

   basename = sys.argv[1].replace('.ipc', '')
   
   tree = MyTransformer().transform(parser.parse(input))

   compiler = IPCCompiler(tree)

   compiler.compile(basename)





if __name__ == '__main__':
   main()
