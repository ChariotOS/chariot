#!/bin/env python3

from lark import Lark, Transformer
from typing import List
from dataclasses import dataclass
import itertools
import sys
import re


grammar = '''
start: (namespace | source | header | include | splat )+

namespace: "namespace" NAME

source: SRC_TYPE "{" message* "}"

message: NAME "(" [ field ("," field)* ] ")" return_fields?

splat: "splat" NAME

return_fields: "return" "(" [ field ("," field)* ] ")"

include: "include" NAME

field: NAME NAME ("=" (STRING | NUMBER))?


header: "header" PATH

PATH: /[\w\.\/]/+
 
NAME: /[\w:\<\>\.\/]/+

SRC_TYPE: "client"|"server"

COMMENT: /\/\/.*/

%import common.LETTER
%import common.ESCAPED_STRING   -> STRING
%import common.SIGNED_NUMBER    -> NUMBER
%import common.WS
%ignore WS
%ignore COMMENT
'''

parser = Lark(grammar)


@dataclass
class Field:
   type: str
   name: str
   default: str

   def __repr__(self):
      return f'{self.type} {self.name}'

   def default_str(self):
      if self.default is None:
         return ''
      return f' = {self.default}'


@dataclass
class Include:
   path: str

@dataclass
class Serializer:
   typename: str

@dataclass
class Message:
   name: str
   fields: List[Field]
   return_fields: List[Field] = None

   def __repr__(self):
      return f'{self.name} ({", ".join(map(str, self.fields))})' + f' returns ({", ".join(map(str, self.return_fields))})' if self.is_sync() else ""

   def enum_name(self):
      return f'{self.source.upper()}_{self.name.upper()}'

   def is_sync(self):
      return self.return_fields is not None
   
   def return_type_string(self):
      if self.is_sync():
         return f'struct {self.source}_{self.name}_response'
      return 'void'

   def return_enum_name(self):
      return f'{self.enum_name()}_RESPONSE'


@dataclass
class Source:
   type: str
   msgs: List[Message]

@dataclass
class Namespace:
   name: str

@dataclass
class Header:
   hdr: str


class MyTransformer(Transformer):

   def SRC_TYPE(self, m):
      return str(m)

   def NAME(self, name):
      return str(name)

   def field(self, f):
      if len(f) == 3:
         (t, n, d) = f
         return Field(t, n, d)

      return Field(f[0], f[1], None)

   def return_fields(self, f):
      return f

   def message(self, m):
      name = m[0]
      fields = []
      return_fields = None
      for f in m[1:]:
         if isinstance(f, Field):
            fields.append(f)
         else:
            return_fields = f
         
      return Message(name, fields, return_fields)

   def source(self, s):
      t = s[0]
      m = s[1:]
      return Source(t, m)

   def start(self, s):
      return s


   def namespace(self, n):
      return Namespace(n[0])

   def header(self, h):
      return Header(str(h[0]))

   def include(self, i):
      return Include(str(i[0]))

   def splat(self, e):
      return Serializer(str(e[0]))



class IPCCompiler:
   def __init__(self, tree):
      self.tree = tree
      self.namespace = None
      self.header = None


      self.client_messages = []
      self.server_messages = []

      self.all_msgs = []
      self.send_map = {}
      self.recv_map = {}


      # go over the top level and decode it
      for tl in tree:
         if isinstance(tl, Namespace):
            self.namespace = tl.name

         if isinstance(tl, Header):
            self.header = tl.hdr

         if isinstance(tl, Source):
            for m in tl.msgs:
               m.source = tl.type
            self.all_msgs.extend(tl.msgs)
            if tl.type == 'client':
               self.send_map['client'] = tl.msgs
               self.recv_map['server'] = tl.msgs
            elif tl.type == 'server':
               self.send_map['server'] = tl.msgs
               self.recv_map['client'] = tl.msgs


      if self.namespace is None:
         raise Exception("No namespace defined")

      
      if self.header is None:
         raise Exception("No header defined")



   def compile_header(self, file):

      def out(*lines):
         file.write('\n'.join(lines) + '\n')

      out('/**')
      out(' *  Generated by ipcc.py. Any changes will be overwritten')
      out(' *')
      out(' * Namespace: {}'.format(self.namespace))
      out(' *')
      out(' * Client messages:')
      out(' *')
      for m in self.send_map['client']:
         out(f' *   {m.name} (')
         for f in m.fields:
            out(f' *     {f.type} {f.name}')
         out(f' *   )')
         out(f' *')


      out(' *')
      out(' * Server messages:')
      out(' *')
      for m in self.send_map['server']:
         out(f' *   {m.name} (')
         for f in m.fields:
            out(f' *     {f.type} {f.name}')
         out(f' *   )')
         out(f' *')
      out(' */')


      out('#pragma once')
      out('#include <ck/ipc.h>')
      out('#include <ck/option.h>')

      out('#include <stdint.h>')
      out('#include <unistd.h>')

      for tl in self.tree:
         if isinstance(tl, Include):
            out(f'#include {tl.path}')


      out('\n')
      out(f'namespace {self.namespace} {{')
      out(f'  // An enumerated identifier for each kind of message')
      out(f'  enum class Message : uint32_t {{')
      all_enums = []
      for m in self.all_msgs:
         all_enums.append(m.enum_name())
         if m.is_sync():
            all_enums.append(m.return_enum_name())
      enum_vals = ",\n    ".join(all_enums)
      out(f'    {enum_vals}')
      out(f'  }};')

      for m in self.all_msgs:
         if m.is_sync():
            out(f'  // return value for {m.name} sent from client')
            out(f'  {m.return_type_string()} {{')
            for f in m.return_fields:
               out(f'    {f.type} {f.name};')
            out(f'  }};')

         print(m)

      out(f'}};\n\n')



      for tl in self.tree:
         if isinstance(tl, Serializer):
            macroname = re.sub('[^a-zA-Z]+', '_', tl.typename).upper()
            out()
            out(f'#ifndef IPC_splat_{macroname}')
            out(f'#define IPC_splat_{macroname}')

            out(f'template <>')
            out(f'inline bool ck::ipc::encode(ck::ipc::encoder& e, {tl.typename}& v) {{')
            out(f'  e.write((void*)&v, sizeof({tl.typename}));')
            out(f'  return true;')
            out(f'}}\n')

            out(f'template <>')
            out(f'inline bool ck::ipc::decode(ck::ipc::decoder& d, {tl.typename}& v) {{')
            out(f'  v = d.next<{tl.typename}>();')
            out(f'  return true;')
            out(f'}}')
            out(f'#endif')

         if isinstance(tl, Source):
            typename = tl.type
            out('\n')
            out(f'namespace {self.namespace} {{')
            out(f'  class {typename}_connection_stub : public ck::ipc::impl::socket_connection {{')
            out(f'    public:')
            out(f'      {typename}_connection_stub(ck::ref<ck::ipcsocket> s) : ck::ipc::impl::socket_connection(s, "{self.namespace}", {"true" if typename == "server" else "false"}) {{}}')
            out(f'      virtual ~{typename}_connection_stub(void) {{}}')
            out('')

            out(f'      // methods to send messages')
            for m in self.send_map[typename]:
               args = [f'{f.type} {f.name}{f.default_str()}' for f in m.fields]

               
               out(f'      inline ck::option<{m.return_type_string()}> {m.name}({", ".join(args)}) {{')
               out(f'        ck::ipc::encoder __e = begin_send();')
               out(f'        __e << (uint32_t){self.namespace}::Message::{m.enum_name()};')
               if m.is_sync():
                  out(f'        ck::ipc::nonce_t __nonce = get_nonce();')
                  out(f'        __e << (ck::ipc::nonce_t)__nonce;')

               for field in m.fields:
                  out(f'        ck::ipc::encode(__e, {field.name});')

               out(f'        this->finish_send();')

               if m.is_sync():
                  out(f'        // wait for the return value from the server :^)')
                  out(f'        {m.return_type_string()} res;')
                  out(f'        auto [data, len] = sync_wait((uint32_t){self.namespace}::Message::{m.return_enum_name()}, __nonce);')
                  out(f'        if (data == NULL && len == 0) return None;')

                  out(f'        ck::ipc::decoder __decoder(data, len);')
                  out(f'        auto __response_type = ({self.namespace}::Message)ck::ipc::decode<uint32_t>(__decoder);')
                  out(f'        auto __response_nonce = ck::ipc::decode<ck::ipc::nonce_t>(__decoder);')

                  out(f'        assert(__response_type == {self.namespace}::Message::{m.return_enum_name()});')
                  out(f'        assert(__response_nonce == __nonce);')


                  for field in m.return_fields:
                     out(f'        ck::ipc::decode(__decoder, res.{field.name});')

                  out(f'        free(data);')
                  out(f'        dispatch();')
                  out(f'        return res;')

               out(f'      }}')
               out()

            out('')
            out(f'      // handle these in your subclass')
            for m in self.recv_map[typename]:
               args = [f'{f.type} {f.name}{f.default_str()}' for f in m.fields]
               out(f'      virtual ck::option<{m.return_type_string()}> on_{m.name}({", ".join(args)}) {{')
               out(f'        fprintf(stderr, "Unimplemneted IPC handler \\"on_{m.name}\\" on {self.namespace} {typename}\\n");')
               if m.is_sync():
                  out(f'        return {{ }};')
               else:
                  out(f'        return;')
               out(f'      }}')

            out('')
            out('')

            out(f'    protected:')
            out(f'      // ^ck::ipc::impl::{typename}_connection')
            out(f'      virtual inline void dispatch_received_message(void *data, size_t len) {{')
            out(f'        ck::ipc::decoder __decoder(data, len);')
            out(f'        {self.namespace}::Message msg_type = ({self.namespace}::Message)ck::ipc::decode<uint32_t>(__decoder);')

            out(f'        switch (msg_type) {{')
            for m in self.recv_map[typename]:
               out(f'          case {self.namespace}::Message::{m.enum_name()}: {{')
               if m.is_sync():
                  out(f'            auto __nonce = ck::ipc::decode<ck::ipc::nonce_t>(__decoder);')
               for field in m.fields:
                  out(f'            {field.type} {field.name};')
               for field in m.fields:
                  out(f'            ck::ipc::decode(__decoder, {field.name});')

               



               args = [f'{f.name}' for f in m.fields]
               if m.is_sync():
                  out(f'            auto __res = on_{m.name}({", ".join(args)});')
                  out(f'            auto __out = __res.unwrap();')
                  out(f'            // now to send the response back')
                  out(f'            ck::ipc::encoder __e = begin_send();')
                  out(f'            __e << (uint32_t){self.namespace}::Message::{m.return_enum_name()};')
                  out(f'            __e << (ck::ipc::nonce_t)__nonce;')

                  for field in m.return_fields:
                     out(f'            ck::ipc::encode(__e, __out.{field.name});')

                  out(f'            this->finish_send();')

               else:
                  out(f'            on_{m.name}({", ".join(args)});')


               out(f'            break;')
               out(f'          }}')

            out(f'          default:')
            out(f'            panic("Unhandled message type %d", msg_type);')
            out(f'            break;')

            out(f'        }}')
            out(f'      }}')
            out(f'  }};')
            out(f'}}')

      


     


   def compile(self, basename):
      with open('./' + self.header, 'w') as f:
         self.compile_header(f)


      
      





def main():
   with open(sys.argv[1], 'r') as f:
      input = f.read()

   basename = sys.argv[1].replace('.ipc', '')
   
   tree = MyTransformer().transform(parser.parse(input))

   compiler = IPCCompiler(tree)

   compiler.compile(basename)





if __name__ == '__main__':
   main()
